<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .cuttable {
            margin: 20px;
            background: #ddd;
            padding: 20px;
            transition: all 0.3s;
            position: relative;
            cursor: crosshair;
            clip-rule: nonzero;
        }

        .part {
            position: absolute;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="cuttable" style="width: 200px; height: 200px; background: #ff6b6b;"></div>
    <div class="cuttable" style="width: 300px; height: 150px; background: #4ecdc4;"></div>
    <div class="cuttable" style="width: 250px; height: 250px; background: #45b7d1;"></div>

    <script>
        let isCutting = false;
        let cutPath = {};

        document.addEventListener('mousedown', startCut);
        document.addEventListener('mousemove', duringCut);
        document.addEventListener('mouseup', finishCut);

        function startCut(e) {    
            console.debug('Start cut');      
            isCutting = true;
        }

        function duringCut(e) {
            if (!isCutting) return;
            if (!e.target.classList.contains('cuttable')) return;

            // store the new point in the cut path
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const point = { x, y};
            cutPath[e.target] = cutPath[e.target] || {"element": e.target, "points": []};
            cutPath[e.target].points.push(point);
            
            // Visual feedback while cutting
            document.body.style.cursor = 'crosshair';
        }

        function finishCut(e) {
            if (!isCutting) return;

            console.debug('Finish cut');
            
            isCutting = false;
            document.body.style.cursor = 'default';

            // TODO: cut all element that were cut
            console.debug('Cutting elements:', cutPath);
            for (const e of Object.keys(cutPath)) {
                const element = cutPath[e].element;
                const points = cutPath[e].points;
                if (points.length < 2) continue; // Need at least two points
                splitElement(element, points);
            }

            // Reset cut path
            cutPath = {};
                
        }

        function splitElement(element, cutPoints) {
            const rect = element.getBoundingClientRect();

            // Convert points to percentages relative to element size
            const pathPoints = cutPoints.map(p => ({
                x: (p.x / rect.width) * 100,
                y: (p.y / rect.height) * 100
            }));
            
            // Create a new part
            const part1 = element.cloneNode(true);

            // Create polygon paths
            const startEdge = getNearestEdge(pathPoints[0], rect);
            const endEdge = getNearestEdge(pathPoints[pathPoints.length - 1], rect);

            // Get projections before creating polygons
            const startProj = projectToEdge(pathPoints[0], startEdge);
            const endProj = projectToEdge(pathPoints[pathPoints.length - 1], endEdge);

            // First part polygon
            const polygonPath = createPathPolygon(pathPoints, startEdge, endEdge, startProj, endProj);
            part1.style.clipPath = polygonPath;
            part1.style.clipRule = 'nonzero';
            
            // Second part gets inverse path
            // element.style.clipPath = createInversePathPolygon(pathPoints, startEdge, endEdge, startProj, endProj);


            const style = getComputedStyle(element);
            const width = parseFloat(style.width);
            const height = parseFloat(style.height);
            const top = parseFloat(style.top);
            const left = parseFloat(style.left);
            const paddingLeft = parseFloat(style.paddingLeft);
            const paddingTop = parseFloat(style.paddingTop);
            const borderLeft = parseFloat(style.borderLeftWidth);
            const borderTop = parseFloat(style.borderTopWidth);
            const contentLeft = left + borderLeft + paddingLeft;
            const contentTop = top + borderTop + paddingTop;

            // Position parts
            [part1].forEach(part => {  // , part2
                console.log(width, height, top, left, paddingLeft, paddingTop, borderLeft, borderTop);
                
                part.classList.add('part');
                part.style.left = `${contentLeft}px`;
                part.style.top = `${contentTop}px`;
                part.style.width = `${width}px`;
                part.style.height = `${height}px`;
            });

            // Add to document
            document.body.appendChild(part1);
            const fallingPart = part1;  // area1 < area2 ? part1 : part2;
            
            // Create a falling animation (slow translation down)
            // https://chatgpt.com/share/68167b11-7c8c-8011-aadd-5fe15a2a2a5d
            // Set initial styles
            fallingPart.style.transform = 'translateY(0)';
            fallingPart.style.transition = 'transform 3s ease-in-out';

            // Force reflow to apply initial styles
            void fallingPart.offsetWidth; // or fallingPart.getBoundingClientRect();

            // Apply the transformation
            fallingPart.style.transform = `translateY(${window.innerHeight}px)`;

            // Remove elements after animation
            setTimeout(() => {
                part1.remove();
            }, 10000);
        }

        // New projection helper
        function projectToEdge(point, edge) {
            return {
                left: {x: 0, y: point.y},
                right: {x: 100, y: point.y},
                top: {x: point.x, y: 0},
                bottom: {x: point.x, y: 100}
            }[edge];
        }

        function getNearestEdge(point, rect) {
            const distances = {
                left: point.x,
                right: 100 - point.x,
                top: point.y,
                bottom: 100 - point.y
            };
            return Object.keys(distances).reduce((a, b) => 
                distances[a] < distances[b] ? a : b
            );
        }

        function createPathPolygon(points, startEdge, endEdge, startProj, endProj) {
            // if startEdge and endEdge are the same, we can use a simple polygon
            if (startEdge === endEdge) {
                return `polygon(
                    ${startProj.x}% ${startProj.y}%,
                    ${points.map(p => `${p.x}% ${p.y}%`).join(",")},
                    ${endProj.x}% ${endProj.y}%
                )`;
            }

            const startCorner = getCornerPoints(startEdge);
            const endCorner = getCornerPoints(endEdge);

            // if startCorner and endCorner share a corner, we can use a simple polygon
            const sharedCorner = startCorner.find(c => endCorner.includes(c));
            if (sharedCorner) {
                return `polygon(
                    ${startProj.x}% ${startProj.y}%,
                    ${points.map(p => `${p.x}% ${p.y}%`).join(",")},
                    ${endProj.x}% ${endProj.y}%,
                    ${sharedCorner}
                )`;
            }

            // otherwise, we need to create a more complex polygon
            const polygon1 = `polygon(
                ${startCorner[1]},
                ${startProj.x}% ${startProj.y}%,
                ${points.map(p => `${p.x}% ${p.y}%`).join(",")},
                ${endProj.x}% ${endProj.y}%,
                ${endCorner[1]}
            )`;

            const polygon0 = `polygon(
                ${startCorner[0]},
                ${startProj.x}% ${startProj.y}%,
                ${points.map(p => `${p.x}% ${p.y}%`).join(",")},
                ${endProj.x}% ${endProj.y}%,
                ${endCorner[0]}
            )`;
            const area1 = calculatePolygonArea(polygon1);
            const area0 = calculatePolygonArea(polygon0);
            console.debug('Area 1:', area1, 'Area 0:', area0);

            return area1 < area0 ? polygon1 : polygon0;
        }

        function createInversePathPolygon(points, startEdge, endEdge, startProj, endProj) {
            // first, get opposite 

            return `polygon(
                ${startCorner.join(",")},
                ${startProj.x}% ${startProj.y}%,
                ${points.map(p => `${p.x}% ${p.y}%`).join(",")},
                ${endProj.x}% ${endProj.y}%,
                ${endCorner.join(",")}
            )`;
        }

        function getCornerPoints(edge) {
            const corners = {
                left: ["0% 0%", "0% 100%"],
                right: ["100% 0%", "100% 100%"],
                top: ["0% 0%", "100% 0%"],
                bottom: ["0% 100%", "100% 100%"]
            };
            return corners[edge];
        }

        function calculateArea(element) {
            const polygon = element.style.clipPath;
            return calculatePolygonArea(polygon);
        }

        function calculatePolygonArea(polygon) {
            const points = polygon.match(/[\d.]+%/g).map(v => parseFloat(v));
            // group points into pairs
            const pairs = [];
            for (let i = 0; i < points.length; i += 2) {
                pairs.push({ x: points[i], y: points[i + 1] });
            }
            // calculate area using the shoelace formula
            let area = 0;
            for (let i = 0; i < pairs.length; i++) {
                const j = (i + 1) % pairs.length;
                area += pairs[i].x * pairs[j].y;
                area -= pairs[j].x * pairs[i].y;
            }
            area = Math.abs(area) / 2;
            return area;
        }
    </script>
</body>
</html>